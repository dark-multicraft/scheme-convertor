<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schematic Converter β</title>
    <link rel="icon" href="favicon.png" type="image/png">
    <meta name="description"
        content="Minecraft Schematicファイル(.nbt, .schem)や3Dモデル(.obj, .stl)をMulticraftのWorldEditコマンドに変換するツール">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Schematic Converter β">
    <meta property="og:description"
        content="Minecraft Schematicファイル(.nbt, .schem)や3Dモデル(.obj, .stl)をMulticraftのWorldEditコマンドに変換するツール">
    <meta property="og:image" content="https://raw.githubusercontent.com/dark-multicraft/scheme-convertor/main/ogp.png">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Schematic Converter β">
    <meta name="twitter:description"
        content="Minecraft Schematicファイル(.nbt, .schem)や3Dモデル(.obj, .stl)をMulticraftのWorldEditコマンドに変換するツール">
    <meta name="twitter:image"
        content="https://raw.githubusercontent.com/dark-multicraft/scheme-convertor/main/ogp.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="multicraft_items.js"></script>
    <!-- Three.js r125 for 3D model loading (older version that supports global namespace) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/loaders/STLLoader.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #f5f5f5;
            color: #222;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            height: 100vh;
            gap: 0;
            background: #f5f5f5;
        }

        .panel {
            background: #fff;
            padding: 20px 24px;
            overflow-y: auto;
            border-left: 1px solid #e8e8e8;
        }

        .panel:first-child {
            border-left: none;
        }

        h1 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 18px;
            color: #111;
            letter-spacing: -0.01em;
        }

        h2 {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        /* Left Panel */
        .drop-zone {
            border: 2px dashed #d0d0d0;
            border-radius: 6px;
            padding: 28px 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.15s;
            margin-bottom: 20px;
            background: #fafafa;
        }

        .drop-zone:hover,
        .drop-zone.dragover {
            border-color: #888;
            background: #f0f0f0;
        }

        .drop-zone p {
            color: #555;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .drop-zone input {
            display: none;
        }

        .setting-group {
            margin-bottom: 16px;
        }

        .setting-group label {
            display: block;
            color: #555;
            font-size: 0.85rem;
            margin-bottom: 5px;
        }

        .setting-group input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d8d8d8;
            border-radius: 4px;
            font-size: 0.95rem;
            background: #fff;
        }

        .setting-group input:focus {
            outline: none;
            border-color: #888;
        }

        .setting-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d8d8d8;
            border-radius: 4px;
            font-size: 0.95rem;
            background: #fff;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23666' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 16px;
            padding-right: 36px;
        }

        .setting-group select:focus {
            outline: none;
            border-color: #888;
        }

        .setting-group select:hover {
            border-color: #aaa;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 0.9rem;
            border-bottom: 1px solid #eee;
        }

        .status-label {
            color: #777;
        }

        .status-value {
            color: #222;
            font-weight: 500;
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 0.85rem;
        }

        .progress-bar {
            width: 100%;
            height: 2px;
            background: #e5e5e5;
            border-radius: 1px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #444;
            width: 0%;
            transition: width 0.2s;
        }

        /* Conditional settings sections */
        .settings-3d {
            display: none;
        }

        .settings-3d.visible {
            display: block;
        }

        .settings-nbt {
            display: none;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        .settings-nbt.visible {
            display: flex;
        }

        .settings-nbt .unknown-list {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 8px;
            background: #fafafa;
        }


        /* Unknown Blocks Modal */
        .unknown-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 900;
            justify-content: center;
            align-items: center;
        }

        .unknown-modal.active {
            display: flex;
        }

        .unknown-modal-content {
            background: #fff;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .unknown-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: #f8f8f8;
            border-bottom: 1px solid #e0e0e0;
        }

        .unknown-modal-header h3 {
            font-size: 1rem;
            font-weight: 600;
            color: #333;
            margin: 0;
        }

        .unknown-modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #888;
            cursor: pointer;
            padding: 0 4px;
        }

        .unknown-modal-close:hover {
            color: #333;
        }

        .unknown-modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
        }

        .unknown-modal-hint {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 16px;
            padding: 10px 12px;
            background: #f5f5f5;
            border-radius: 4px;
        }

        .unknown-modal-footer {
            padding: 16px 20px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .unknown-modal-footer button {
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.15s;
        }

        .unknown-modal-footer .btn-primary {
            background: #222;
            color: #fff;
            border: none;
        }

        .unknown-modal-footer .btn-primary:hover {
            background: #333;
        }

        .unknown-modal-footer .btn-secondary {
            background: #fff;
            color: #333;
            border: 1px solid #ccc;
        }

        .unknown-modal-footer .btn-secondary:hover {
            background: #f5f5f5;
        }

        /* Center Panel */
        .center-panel {
            display: flex;
            flex-direction: column;
        }

        .unknown-header {
            padding-bottom: 14px;
            border-bottom: 1px solid #eee;
            margin-bottom: 14px;
        }

        .unknown-hint {
            font-size: 0.85rem;
            color: #888;
            margin-top: 6px;
        }

        .unknown-list {
            flex: 1;
            overflow-y: auto;
        }

        .unknown-item {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 14px;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
            align-items: center;
        }

        .unknown-name {
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 0.8rem;
            color: #333;
            word-break: break-all;
        }

        .unknown-count {
            font-size: 0.8rem;
            color: #888;
        }

        .autocomplete-wrapper {
            position: relative;
        }

        .unknown-input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #d8d8d8;
            border-radius: 4px;
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 0.85rem;
            background: #fff;
        }

        .unknown-input:focus {
            outline: none;
            border-color: #888;
        }

        .autocomplete-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #fff;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        .autocomplete-list.visible {
            display: block;
        }

        .autocomplete-item {
            padding: 8px 10px;
            cursor: pointer;
            font-size: 0.85rem;
            border-bottom: 1px solid #eee;
        }

        .autocomplete-item:hover {
            background: #f0f0f0;
        }

        .autocomplete-item .item-id {
            font-family: 'SF Mono', Consolas, monospace;
            color: #333;
        }

        .autocomplete-item .item-name {
            color: #777;
            font-size: 0.75rem;
        }

        .convert-btn {
            margin-top: 16px;
            width: 100%;
            padding: 12px;
            background: #222;
            color: #fff;
            border: none;
            border-radius: 4px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.15s;
        }

        .convert-btn:hover {
            background: #333;
        }

        .convert-btn:disabled {
            background: #bbb;
            cursor: not-allowed;
        }

        /* Right Panel */
        .log-panel {
            font-family: 'SF Mono', Consolas, 'Courier New', monospace;
            font-size: 0.8rem;
            flex: 1;
            overflow-y: auto;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 12px 14px;
            margin-bottom: 16px;
            line-height: 1.6;
        }

        .log-entry {
            padding: 2px 0;
            color: #555;
        }

        .log-entry.success {
            color: #2a8;
        }

        .log-entry.error {
            color: #d44;
        }

        .log-entry.warning {
            color: #a80;
        }

        .download-area {
            margin-top: auto;
        }

        .download-item {
            margin-bottom: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 12px 14px;
            background: #fafafa;
        }

        .download-item-header {
            font-size: 0.9rem;
            color: #444;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .download-buttons {
            display: flex;
            gap: 8px;
        }

        .download-link {
            flex: 1;
            display: block;
            background: #222;
            color: #fff;
            padding: 10px 14px;
            border-radius: 4px;
            text-decoration: none;
            font-size: 0.85rem;
            text-align: center;
            transition: background 0.15s;
        }

        .download-link:hover {
            background: #333;
        }

        .copy-btn {
            flex: 1;
            background: #555;
            color: #fff;
            padding: 10px 14px;
            border-radius: 4px;
            border: none;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background 0.15s;
        }

        .copy-btn:hover {
            background: #666;
        }

        .copy-btn.copied {
            background: #3a3;
        }

        .empty-state {
            color: #999;
            font-size: 0.85rem;
            text-align: center;
            padding: 40px 20px;
        }

        /* Voxel Preview Modal */
        .preview-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
        }

        .preview-modal.active {
            display: flex;
            flex-direction: column;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .preview-title {
            color: #fff;
            font-size: 1rem;
            font-weight: 500;
        }

        .preview-info {
            color: #888;
            font-size: 0.85rem;
        }

        .preview-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0 8px;
        }

        .preview-close:hover {
            color: #f55;
        }

        .preview-canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #previewCanvas {
            width: 100%;
            height: 100%;
        }

        .preview-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 16px;
            border-radius: 8px;
        }

        .preview-controls button {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .preview-controls button:hover {
            background: #444;
        }

        .preview-hint {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #888;
            font-size: 0.75rem;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 4px;
        }

        .preview-btn {
            margin-top: 8px;
            width: 100%;
            padding: 8px;
            background: #555;
            color: #fff;
            border: none;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
        }

        .preview-btn:hover {
            background: #666;
        }

        .preview-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Command Preview */
        .command-preview {
            margin-top: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .command-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: #f5f5f5;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
        }

        .command-preview-header:hover {
            background: #eee;
        }

        .command-preview-title {
            font-size: 0.8rem;
            color: #666;
        }

        .command-preview-toggle {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 0.75rem;
            padding: 2px 6px;
        }

        .command-preview-content {
            max-height: 300px;
            overflow-y: auto;
            background: #1e1e1e;
            padding: 10px;
            font-family: monospace;
            font-size: 0.7rem;
            line-height: 1.4;
        }

        .command-preview-content.collapsed {
            display: none;
        }

        .cmd-line {
            color: #d4d4d4;
            white-space: pre;
            display: block;
        }

        .cmd-shift {
            color: #6a9955;
        }

        .cmd-set {
            color: #569cd6;
        }

        .cmd-param {
            color: #ce9178;
        }

        /* Clean UI Styles */
        .drop-zone {
            border: 1px dashed #ccc;
            border-radius: 4px;
            padding: 32px 16px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.15s, background 0.15s;
            margin-bottom: 16px;
            background: #fafafa;
        }

        .drop-zone:hover,
        .drop-zone.dragover {
            border-color: #666;
            background: #f5f5f5;
        }

        .drop-zone-icon {
            font-size: 2rem;
            color: #999;
            line-height: 1;
            margin-bottom: 8px;
        }

        .drop-zone-text {
            color: #555;
            font-size: 0.9rem;
            margin-bottom: 4px;
        }

        .drop-zone-hint {
            color: #999;
            font-size: 0.75rem;
        }

        .drop-zone input {
            display: none;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: #e8f5e9;
            border-radius: 4px;
            margin-bottom: 16px;
            font-size: 0.85rem;
        }

        .status-bar #fileName {
            color: #2e7d32;
            font-weight: 500;
        }

        .status-bar #blockCount {
            color: #666;
        }

        .settings-section {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        .settings-group-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: 10px;
            padding-top: 12px;
            border-top: 1px solid #eee;
        }

        .action-section {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .btn-primary {
            flex: 1;
            background: #222;
            color: #fff;
            border: none;
            padding: 12px 16px;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.15s;
        }

        .btn-primary:hover:not(:disabled) {
            background: #333;
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-secondary {
            flex: 0 0 auto;
            background: #fff;
            color: #333;
            border: 1px solid #ddd;
            padding: 12px 16px;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #f5f5f5;
            border-color: #bbb;
        }

        .btn-secondary:disabled {
            color: #aaa;
            cursor: not-allowed;
        }

        .progress-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .progress-section .progress-bar {
            flex: 1;
            margin: 0;
        }

        .progress-label {
            font-size: 0.8rem;
            color: #666;
            min-width: 60px;
            text-align: right;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            overflow-y: hidden;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
        }

        .output-tabs {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            margin-bottom: 12px;
        }

        .output-tabs .tab {
            padding: 8px 0;
            font-size: 0.85rem;
            font-weight: 500;
            color: #333;
            border-bottom: 2px solid #333;
        }

        .log-panel {
            flex: 1;
            min-height: 200px;
        }

        .download-area {
            flex-shrink: 0;
            margin-top: auto;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Left Panel -->
        <div class="panel left-panel">
            <h1>Schematic Converter β</h1>

            <div class="drop-zone" id="dropZone">
                <div class="drop-zone-content">
                    <div class="drop-zone-icon">+</div>
                    <div class="drop-zone-text">ファイルをドロップまたはクリック</div>
                    <div class="drop-zone-hint">.nbt .schem .we .obj .stl</div>
                </div>
                <input type="file" id="fileInput" accept=".nbt,.schem,.we,.obj,.stl,.mtl" multiple>
            </div>

            <div class="status-bar" id="statusBar" style="display:none;">
                <span id="fileName"></span>
                <span id="blockCount"></span>
            </div>

            <div class="settings-section">
                <div class="settings-grid">
                    <div class="setting-group">
                        <label>最大行数</label>
                        <input type="number" id="maxLines" value="30000" min="1000" max="100000">
                    </div>
                    <div class="setting-group">
                        <label>スケール</label>
                        <input type="number" id="scale" value="1" min="1" max="10">
                    </div>
                </div>

                <div class="settings-3d" id="settings3D">
                    <div class="settings-group-title">3Dモデル</div>
                    <div class="settings-grid">
                        <div class="setting-group">
                            <label>解像度</label>
                            <input type="number" id="resolution" value="0.5" min="0.01" max="10" step="0.01">
                        </div>
                        <div class="setting-group">
                            <label>彩色方法</label>
                            <select id="colorMode">
                                <option value="single">単一ブロック</option>
                                <option value="wool">ウールのみ</option>
                                <option value="concrete">コンクリートのみ</option>
                                <option value="terracotta">テラコッタのみ</option>
                                <option value="glass">ガラスのみ</option>
                                <option value="all" selected>すべてのカラーブロック</option>
                            </select>
                        </div>
                    </div>
                    <div class="setting-group" id="blockIdGroup" style="display: none;">
                        <label>ブロック</label>
                        <input type="text" id="blockId" value="default:stone">
                    </div>
                </div>

                <div class="settings-nbt" id="settingsNBT">
                    <div class="settings-group-title">未対応ブロック</div>
                    <div class="unknown-hint">空欄=デフォルト / air=スキップ</div>
                    <div class="unknown-list" id="unknownList"></div>
                </div>
            </div>

            <div class="action-section">
                <button class="btn-primary" id="convertBtn" disabled>変換</button>
                <button class="btn-secondary" id="previewBtn" disabled>プレビュー</button>
            </div>

            <div class="progress-section" id="progressSection" style="display:none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-label" id="commandCount"></div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="panel right-panel">
            <div class="output-tabs">
                <span class="tab active">ログ</span>
            </div>
            <div class="log-panel" id="logPanel"></div>
            <div class="download-area" id="downloadArea"></div>
        </div>
    </div><!-- Preview Modal -->
    <div class="preview-modal" id="previewModal">
        <div class="preview-header">
            <span class="preview-title">ボクセルプレビュー</span>
            <span class="preview-info" id="previewInfo"></span>
            <button class="preview-close" id="previewClose">&times;</button>
        </div>
        <div class="preview-canvas-container">
            <canvas id="previewCanvas"></canvas>
            <div class="preview-hint">ドラッグで回転 / スクロールでズーム</div>
            <div class="preview-controls">
                <button id="resetViewBtn">リセット</button>
                <button id="toggleWireBtn">ワイヤー表示</button>
            </div>
        </div>
    </div>

    <script>
        // ========== Block Mapping ==========
        const BLOCK_MAPPING = {
            // === 基本ブロック ===
            "minecraft:air": null, // Skip air blocks
            "minecraft:stone": "default:stone",
            "minecraft:granite": "default:stone",
            "minecraft:polished_granite": "default:stone",
            "minecraft:diorite": "default:stone",
            "minecraft:polished_diorite": "default:stone",
            "minecraft:andesite": "default:stone",
            "minecraft:polished_andesite": "default:stone",
            "minecraft:grass_block": "default:dirt_with_grass",
            "minecraft:grass": "default:dirt_with_grass",
            "minecraft:dirt": "default:dirt",
            "minecraft:coarse_dirt": "default:dirt",
            "minecraft:podzol": "default:dirt",
            "minecraft:cobblestone": "default:cobble",

            // === 木材 ===
            "minecraft:planks": "default:wood",
            "minecraft:oak_planks": "default:wood",
            "minecraft:spruce_planks": "default:pine_wood",
            "minecraft:birch_planks": "default:birch_wood",
            "minecraft:jungle_planks": "default:junglewood",
            "minecraft:acacia_planks": "default:acacia_wood",
            "minecraft:dark_oak_planks": "default:wood",

            // === 原木 ===
            "minecraft:log": "default:tree",
            "minecraft:oak_log": "default:tree",
            "minecraft:spruce_log": "default:pine_tree",
            "minecraft:birch_log": "default:birch_tree",
            "minecraft:jungle_log": "default:jungletree",
            "minecraft:acacia_log": "default:acacia_tree",
            "minecraft:dark_oak_log": "default:tree",

            // === 葉 ===
            "minecraft:leaves": "default:leaves",
            "minecraft:oak_leaves": "default:leaves",
            "minecraft:spruce_leaves": "default:pine_needles",
            "minecraft:birch_leaves": "default:birch_leaves",
            "minecraft:jungle_leaves": "default:jungleleaves",
            "minecraft:acacia_leaves": "default:acacia_leaves",
            "minecraft:dark_oak_leaves": "default:leaves",
            "minecraft:leaves2": "default:acacia_leaves",

            // === 砂・砂利 ===
            "minecraft:sand": "default:sand",
            "minecraft:red_sand": "default:redsand",
            "minecraft:gravel": "default:gravel",
            "minecraft:sandstone": "default:sandstone",
            "minecraft:chiseled_sandstone": "default:sandstonecarved",
            "minecraft:smooth_sandstone": "default:sandstonesmooth",
            "minecraft:red_sandstone": "default:redsandstone",

            // === 鉱石 ===
            "minecraft:gold_ore": "default:stone_with_gold",
            "minecraft:iron_ore": "default:stone_with_iron",
            "minecraft:coal_ore": "default:stone_with_coal",
            "minecraft:diamond_ore": "default:stone_with_diamond",
            "minecraft:emerald_ore": "default:stone_with_emerald",
            "minecraft:lapis_ore": "default:stone_with_bluestone",
            "minecraft:redstone_ore": "default:stone_with_bluestone",
            "minecraft:copper_ore": "default:stone_with_copper",
            "minecraft:quartz_ore": "default:quartz_ore",

            // === 鉱石ブロック ===
            "minecraft:gold_block": "default:goldblock",
            "minecraft:iron_block": "default:steelblock",
            "minecraft:diamond_block": "default:diamondblock",
            "minecraft:emerald_block": "default:emeraldblock",
            "minecraft:lapis_block": "default:stone",
            "minecraft:coal_block": "default:coalblock",
            "minecraft:copper_block": "default:copperblock",
            "minecraft:quartz_block": "default:quartz_block",
            "minecraft:chiseled_quartz_block": "default:quartz_chiseled",
            "minecraft:quartz_pillar": "default:quartz_pillar",

            // === レンガ・石材 ===
            "minecraft:brick_block": "default:brick",
            "minecraft:bricks": "default:brick",
            "minecraft:stonebrick": "default:stonebrick",
            "minecraft:stone_bricks": "default:stonebrick",
            "minecraft:mossy_stone_bricks": "default:stonebrickmossy",
            "minecraft:cracked_stone_bricks": "default:stonebrickcracked",
            "minecraft:chiseled_stone_bricks": "default:stonebrickcarved",
            "minecraft:mossy_cobblestone": "default:mossycobble",
            "minecraft:nether_brick": "default:brick",

            // === ガラス ===
            "minecraft:glass": "default:glass",
            "minecraft:glass_pane": "default:glass",
            "minecraft:stained_glass": "default:glass",
            "minecraft:white_stained_glass": "default:glass_white",
            "minecraft:orange_stained_glass": "default:glass_orange",
            "minecraft:magenta_stained_glass": "default:glass_magenta",
            "minecraft:light_blue_stained_glass": "default:glass_cyan",
            "minecraft:yellow_stained_glass": "default:glass_yellow",
            "minecraft:lime_stained_glass": "default:glass_green",
            "minecraft:pink_stained_glass": "default:glass_pink",
            "minecraft:gray_stained_glass": "default:glass_grey",
            "minecraft:light_gray_stained_glass": "default:glass_grey",
            "minecraft:cyan_stained_glass": "default:glass_cyan",
            "minecraft:purple_stained_glass": "default:glass_violet",
            "minecraft:blue_stained_glass": "default:glass_blue",
            "minecraft:brown_stained_glass": "default:glass_brown",
            "minecraft:green_stained_glass": "default:glass_dark_green",
            "minecraft:red_stained_glass": "default:glass_red",
            "minecraft:black_stained_glass": "default:glass_black",

            // === 羊毛 ===
            "minecraft:wool": "wool:white",
            "minecraft:white_wool": "wool:white",
            "minecraft:orange_wool": "wool:orange",
            "minecraft:magenta_wool": "wool:magenta",
            "minecraft:light_blue_wool": "wool:cyan",
            "minecraft:yellow_wool": "wool:yellow",
            "minecraft:lime_wool": "wool:green",
            "minecraft:pink_wool": "wool:pink",
            "minecraft:gray_wool": "wool:grey",
            "minecraft:light_gray_wool": "wool:grey",
            "minecraft:cyan_wool": "wool:cyan",
            "minecraft:purple_wool": "wool:violet",
            "minecraft:blue_wool": "wool:blue",
            "minecraft:brown_wool": "wool:brown",
            "minecraft:green_wool": "wool:dark_green",
            "minecraft:red_wool": "wool:red",
            "minecraft:black_wool": "wool:black",

            // === テラコッタ ===
            "minecraft:hardened_clay": "default:hardened_clay",
            "minecraft:terracotta": "default:hardened_clay",
            "minecraft:white_terracotta": "hardened_clay:white",
            "minecraft:orange_terracotta": "hardened_clay:orange",
            "minecraft:magenta_terracotta": "hardened_clay:magenta",
            "minecraft:light_blue_terracotta": "hardened_clay:cyan",
            "minecraft:yellow_terracotta": "hardened_clay:yellow",
            "minecraft:lime_terracotta": "hardened_clay:green",
            "minecraft:pink_terracotta": "hardened_clay:pink",
            "minecraft:gray_terracotta": "hardened_clay:grey",
            "minecraft:light_gray_terracotta": "hardened_clay:grey",
            "minecraft:cyan_terracotta": "hardened_clay:cyan",
            "minecraft:purple_terracotta": "hardened_clay:violet",
            "minecraft:blue_terracotta": "hardened_clay:blue",
            "minecraft:brown_terracotta": "hardened_clay:brown",
            "minecraft:green_terracotta": "hardened_clay:dark_green",
            "minecraft:red_terracotta": "hardened_clay:red",
            "minecraft:black_terracotta": "hardened_clay:black",
            "minecraft:stained_hardened_clay": "default:hardened_clay",

            // === コンクリート ===
            "minecraft:concrete": "concrete:concrete",
            "minecraft:white_concrete": "concrete:concrete_white",
            "minecraft:orange_concrete": "concrete:concrete_orange",
            "minecraft:magenta_concrete": "concrete:concrete_magenta",
            "minecraft:light_blue_concrete": "concrete:concrete_cyan",
            "minecraft:yellow_concrete": "concrete:concrete_yellow",
            "minecraft:lime_concrete": "concrete:concrete_green",
            "minecraft:pink_concrete": "concrete:concrete_pink",
            "minecraft:gray_concrete": "concrete:concrete_grey",
            "minecraft:light_gray_concrete": "concrete:concrete_grey",
            "minecraft:cyan_concrete": "concrete:concrete_cyan",
            "minecraft:purple_concrete": "concrete:concrete_violet",
            "minecraft:blue_concrete": "concrete:concrete_blue",
            "minecraft:brown_concrete": "concrete:concrete_brown",
            "minecraft:green_concrete": "concrete:concrete_dark_green",
            "minecraft:red_concrete": "concrete:concrete_red",
            "minecraft:black_concrete": "concrete:concrete_black",

            // === その他ブロック ===
            "minecraft:bedrock": "default:stone",
            "minecraft:water": "default:water_source",
            "minecraft:flowing_water": "default:water_flowing",
            "minecraft:lava": "default:lava_source",
            "minecraft:flowing_lava": "default:lava_flowing",
            "minecraft:sponge": "sponge:sponge",
            "minecraft:obsidian": "default:obsidian",
            "minecraft:glowstone": "default:glowstone",
            "minecraft:ice": "default:ice",
            "minecraft:packed_ice": "default:packedice",
            "minecraft:snow": "default:snowblock",
            "minecraft:snow_block": "default:snowblock",
            "minecraft:snow_layer": "default:snowblock",
            "minecraft:clay": "default:clay",
            "minecraft:cactus": "default:cactus",
            "minecraft:bookshelf": "shelf:bookshelf",
            "minecraft:slime": "bluestone_stickyblocks:slimeblock",
            "minecraft:slime_block": "bluestone_stickyblocks:slimeblock",
            "minecraft:melon": "farming_plants:watermelon_fruit",
            "minecraft:melon_block": "farming_plants:watermelon_fruit",
            "minecraft:pumpkin": "farming_plants:pumpkin_fruit",
            "minecraft:hay_block": "farming:straw",

            // === 機能ブロック ===
            "minecraft:chest": "default:chest",
            "minecraft:crafting_table": "workbench:workbench",
            "minecraft:furnace": "default:furnace",
            "minecraft:lit_furnace": "default:furnace",

            // === 階段 (基本マッピング) ===
            "minecraft:oak_stairs": "stairs:stair_default_wood",
            "minecraft:spruce_stairs": "stairs:stair_default_pine_wood",
            "minecraft:birch_stairs": "stairs:stair_default_birch_wood",
            "minecraft:jungle_stairs": "stairs:stair_default_junglewood",
            "minecraft:acacia_stairs": "stairs:stair_default_acacia_wood",
            "minecraft:dark_oak_stairs": "stairs:stair_default_wood",
            "minecraft:stone_stairs": "stairs:stair_default_cobble",
            "minecraft:cobblestone_stairs": "stairs:stair_default_cobble",
            "minecraft:brick_stairs": "stairs:stair_default_brick",
            "minecraft:stone_brick_stairs": "stairs:stair_default_stonebrick",
            "minecraft:sandstone_stairs": "stairs:stair_default_sandstone",
            "minecraft:quartz_stairs": "stairs:stair_default_quartz_block",

            // === ハーフブロック (基本マッピング) ===
            "minecraft:stone_slab": "stairs:slab_default_stone",
            "minecraft:oak_slab": "stairs:slab_default_wood",
            "minecraft:spruce_slab": "stairs:slab_default_pine_wood",
            "minecraft:birch_slab": "stairs:slab_default_birch_wood",
            "minecraft:jungle_slab": "stairs:slab_default_junglewood",
            "minecraft:acacia_slab": "stairs:slab_default_acacia_wood",
            "minecraft:dark_oak_slab": "stairs:slab_default_wood",
            "minecraft:brick_slab": "stairs:slab_default_brick",
            "minecraft:stone_brick_slab": "stairs:slab_default_stonebrick",
            "minecraft:sandstone_slab": "stairs:slab_default_sandstone",
            "minecraft:quartz_slab": "stairs:slab_default_quartz_block",

            // === 松明・照明 ===
            "minecraft:torch": "default:torch",
            "minecraft:wall_torch": "default:torch",
            "minecraft:lantern": "lanterns:lantern_off",
            "minecraft:soul_lantern": "lanterns:lantern_off",
            "minecraft:redstone_lamp": "default:glowstone",
            "minecraft:lit_redstone_lamp": "default:glowstone",

            // === はしご ===
            "minecraft:ladder": "default:ladder_wood",

            // === フェンス ===
            "minecraft:fence": "default:fence_wood",
            "minecraft:oak_fence": "default:fence_wood",
            "minecraft:spruce_fence": "default:fence_pine_wood",
            "minecraft:birch_fence": "default:fence_birch_wood",
            "minecraft:jungle_fence": "default:fence_jungle_wood",
            "minecraft:acacia_fence": "default:fence_acacia_wood",
            "minecraft:dark_oak_fence": "default:fence_wood",
            "minecraft:nether_brick_fence": "default:fence_wood",

            // === フェンスゲート ===
            "minecraft:fence_gate": "doors:gate_wood",
            "minecraft:oak_fence_gate": "doors:gate_wood",
            "minecraft:spruce_fence_gate": "doors:gate_pine_wood",
            "minecraft:birch_fence_gate": "doors:gate_birch_wood",
            "minecraft:jungle_fence_gate": "doors:gate_jungle_wood",
            "minecraft:acacia_fence_gate": "doors:gate_acacia_wood",
            "minecraft:dark_oak_fence_gate": "doors:gate_wood",

            // === ドア ===
            "minecraft:wooden_door": "doors:door_wood",
            "minecraft:oak_door": "doors:door_wood",
            "minecraft:spruce_door": "doors:door_pine_wood",
            "minecraft:birch_door": "doors:door_birch_wood",
            "minecraft:jungle_door": "doors:door_jungle_wood",
            "minecraft:acacia_door": "doors:door_acacia_wood",
            "minecraft:dark_oak_door": "doors:door_wood",
            "minecraft:iron_door": "doors:door_steel",

            // === トラップドア ===
            "minecraft:trapdoor": "doors:trapdoor",
            "minecraft:oak_trapdoor": "doors:trapdoor",
            "minecraft:spruce_trapdoor": "doors:trapdoor_pine_wood",
            "minecraft:birch_trapdoor": "doors:trapdoor_birch_wood",
            "minecraft:jungle_trapdoor": "doors:trapdoor_jungle_wood",
            "minecraft:acacia_trapdoor": "doors:trapdoor_acacia_wood",
            "minecraft:dark_oak_trapdoor": "doors:trapdoor",
            "minecraft:iron_trapdoor": "doors:trapdoor_steel",

            // === ベッド ===
            "minecraft:bed": "beds:bed_red",
            "minecraft:white_bed": "beds:bed_white",
            "minecraft:orange_bed": "beds:bed_orange",
            "minecraft:magenta_bed": "beds:bed_magenta",
            "minecraft:light_blue_bed": "beds:bed_cyan",
            "minecraft:yellow_bed": "beds:bed_yellow",
            "minecraft:lime_bed": "beds:bed_green",
            "minecraft:pink_bed": "beds:bed_pink",
            "minecraft:gray_bed": "beds:bed_grey",
            "minecraft:light_gray_bed": "beds:bed_grey",
            "minecraft:cyan_bed": "beds:bed_cyan",
            "minecraft:purple_bed": "beds:bed_violet",
            "minecraft:blue_bed": "beds:bed_blue",
            "minecraft:brown_bed": "beds:bed_brown",
            "minecraft:green_bed": "beds:bed_dark_green",
            "minecraft:red_bed": "beds:bed_red",
            "minecraft:black_bed": "beds:bed_black",

            // === レール ===
            "minecraft:rail": "carts:rail",
            "minecraft:golden_rail": "carts:rail",
            "minecraft:powered_rail": "carts:rail",
            "minecraft:detector_rail": "carts:rail",
            "minecraft:activator_rail": "carts:rail",

            // === TNT ===
            "minecraft:tnt": "tnt:tnt",

            // === ガラス板・鉄格子 ===
            "minecraft:stained_glass_pane": "xpanes:pane_flat",
            "minecraft:iron_bars": "xpanes:bar_flat",

            // === クモの巣 ===
            "minecraft:web": "mobs_monsters:cobweb",
            "minecraft:cobweb": "mobs_monsters:cobweb",

            // === サンゴブロック ===
            "minecraft:tube_coral_block": "ocean:coral_blue_tubular_block",
            "minecraft:brain_coral_block": "ocean:coral_pink_acropora_block",
            "minecraft:bubble_coral_block": "ocean:coral_yellow_fiery_block",
            "minecraft:fire_coral_block": "ocean:coral_red_rubrum_block",
            "minecraft:horn_coral_block": "ocean:coral_yellow_fiery_block",

            // === 看板 ===
            "minecraft:standing_sign": "signs:sign",
            "minecraft:wall_sign": "signs:sign",
            "minecraft:oak_sign": "signs:sign",
            "minecraft:spruce_sign": "signs:sign_pine_wood",
            "minecraft:birch_sign": "signs:sign_birch_wood",
            "minecraft:jungle_sign": "signs:sign_junglewood",
            "minecraft:acacia_sign": "signs:sign_acacia_wood",
            "minecraft:dark_oak_sign": "signs:sign",

            // === その他の追加ブロック ===
            "minecraft:bamboo": "water_plants:bamboo",
            "minecraft:lily_pad": "swamp_biome:waterlily",
            "minecraft:waterlily": "swamp_biome:waterlily",
            "minecraft:jack_o_lantern": "farming_plants:pumpkin_fruit",
            "minecraft:lit_pumpkin": "farming_plants:pumpkin_fruit",
            "minecraft:carved_pumpkin": "farming_plants:pumpkin_fruit",
            "minecraft:jukebox": "default:chest",
            "minecraft:enchanting_table": "x_enchanting:table",
            "minecraft:brewing_stand": "brewing:stand",
            "minecraft:armor_stand": "3d_armor_stand:armor_stand",
            "minecraft:flower_pot": "flowers:pot",
            "minecraft:painting": "painting:painting",
            "minecraft:item_frame": "itemframes:frame",
        };

        // ========== NBT Parser ==========
        class NBTReader {
            constructor(buffer) {
                this.view = new DataView(buffer);
                this.offset = 0;
            }
            readByte() { return this.view.getInt8(this.offset++); }
            readShort() { const v = this.view.getInt16(this.offset, false); this.offset += 2; return v; }
            readInt() { const v = this.view.getInt32(this.offset, false); this.offset += 4; return v; }
            readLong() {
                const h = this.view.getInt32(this.offset, false);
                const l = this.view.getUint32(this.offset + 4, false);
                this.offset += 8;
                return BigInt(h) * BigInt(0x100000000) + BigInt(l);
            }
            readFloat() { const v = this.view.getFloat32(this.offset, false); this.offset += 4; return v; }
            readDouble() { const v = this.view.getFloat64(this.offset, false); this.offset += 8; return v; }
            readString() {
                const len = this.view.getUint16(this.offset, false);
                this.offset += 2;
                const bytes = new Uint8Array(this.view.buffer, this.offset, len);
                this.offset += len;
                return new TextDecoder('utf-8').decode(bytes);
            }
            readByteArray() {
                const len = this.readInt();
                const arr = new Int8Array(this.view.buffer, this.offset, len);
                this.offset += len;
                return Array.from(arr);
            }
            readIntArray() {
                const len = this.readInt();
                const arr = [];
                for (let i = 0; i < len; i++) arr.push(this.readInt());
                return arr;
            }
            readLongArray() {
                const len = this.readInt();
                const arr = [];
                for (let i = 0; i < len; i++) arr.push(this.readLong());
                return arr;
            }
            readList() {
                const type = this.readByte();
                const len = this.readInt();
                const list = [];
                for (let i = 0; i < len; i++) list.push(this.readTag(type));
                return list;
            }
            readCompound() {
                const compound = {};
                while (true) {
                    const type = this.readByte();
                    if (type === 0) break;
                    const name = this.readString();
                    compound[name] = this.readTag(type);
                }
                return compound;
            }
            readTag(type) {
                switch (type) {
                    case 0: return null;
                    case 1: return this.readByte();
                    case 2: return this.readShort();
                    case 3: return this.readInt();
                    case 4: return this.readLong();
                    case 5: return this.readFloat();
                    case 6: return this.readDouble();
                    case 7: return this.readByteArray();
                    case 8: return this.readString();
                    case 9: return this.readList();
                    case 10: return this.readCompound();
                    case 11: return this.readIntArray();
                    case 12: return this.readLongArray();
                    default: throw new Error(`Unknown tag: ${type}`);
                }
            }
            parse() {
                const type = this.readByte();
                if (type !== 10) throw new Error('Invalid root');
                this.readString();
                return this.readCompound();
            }
        }

        // ========== State ==========
        let currentBlocks = [];
        let current3DVoxels = [];
        let unknownBlocks = {};
        let userMappings = {};
        let currentFileName = '';
        let is3DModel = false;
        let isWorldEdit = false;
        let userResolutionLocked = false;
        let currentGeometry = null;

        // ========== DOM ==========
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const unknownList = document.getElementById('unknownList');
        const convertBtn = document.getElementById('convertBtn');
        const downloadArea = document.getElementById('downloadArea');
        const logPanel = document.getElementById('logPanel');
        const resolutionInput = document.getElementById('resolution');
        const settings3D = document.getElementById('settings3D');
        const settingsNBT = document.getElementById('settingsNBT');
        const colorModeSelect = document.getElementById('colorMode');
        const blockIdGroup = document.getElementById('blockIdGroup');

        // Track if the user manually edited the resolution so we don't overwrite it on the next file
        resolutionInput.addEventListener('input', () => { userResolutionLocked = true; });

        // 彩色方法の変更時にブロック入力欄の表示/非表示を切り替え
        colorModeSelect.addEventListener('change', () => {
            if (colorModeSelect.value === 'single') {
                blockIdGroup.style.display = 'block';
            } else {
                blockIdGroup.style.display = 'none';
            }
        });

        // Toggle settings sections visibility
        function updateSettingsVisibility() {
            if (is3DModel) {
                settings3D.classList.add('visible');
                settingsNBT.classList.remove('visible');
            } else {
                settings3D.classList.remove('visible');
                if (Object.keys(unknownBlocks).length > 0) {
                    settingsNBT.classList.add('visible');
                } else {
                    settingsNBT.classList.remove('visible');
                }
            }
        }

        // backward compat
        function update3DSettingsVisibility() {
            updateSettingsVisibility();
        }


        // ========== Utils ==========
        function log(msg, type = '') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = msg;
            logPanel.appendChild(entry);
            logPanel.scrollTop = logPanel.scrollHeight;
        }

        function updateStatus(key, value) {
            const el = document.getElementById(key);
            if (el) el.textContent = value;
        }

        function setProgress(pct) {
            document.getElementById('progressFill').style.width = `${pct}%`;
        }

        function parseBlockState(name) {
            if (!name.includes('[')) return [name, {}];
            const base = name.split('[')[0];
            const statesStr = name.split('[')[1].replace(']', '');
            const states = {};
            for (const pair of statesStr.split(',')) {
                if (pair.includes('=')) {
                    const [k, v] = pair.split('=');
                    states[k.trim()] = v.trim();
                }
            }
            return [base, states];
        }

        function isStair(name) { return name.toLowerCase().includes('stairs'); }
        function isSlab(name) { return name.toLowerCase().includes('slab'); }

        function getParam2Stairs(states) {
            const map = { north: 2, south: 0, east: 1, west: 3 };
            let p = map[states.facing] || 0;
            if (states.half === 'top') p += 20;
            return p;
        }

        function getParam2Slab(states) {
            if (states.type === 'top') return 20;
            if (states.type === 'double') return -1;
            return 0;
        }

        function getMulticraftBlock(mcName) {
            let [base, states] = parseBlockState(mcName.toLowerCase());
            if (!base.startsWith('minecraft:')) base = 'minecraft:' + base;

            let param2 = 0;
            if (isStair(base)) param2 = getParam2Stairs(states);
            else if (isSlab(base)) param2 = getParam2Slab(states);

            if (userMappings[base] !== undefined) {
                if (userMappings[base] === null) return [null, 0];
                return [userMappings[base], param2];
            }
            if (BLOCK_MAPPING[base] !== undefined) {
                if (BLOCK_MAPPING[base] === null) return [null, 0];
                return [BLOCK_MAPPING[base], param2];
            }
            return [base.replace('minecraft:', 'default:'), param2];
        }

        // ========== Autocomplete ==========
        function setupAutocomplete(input) {
            const wrapper = input.parentElement;
            const list = wrapper.querySelector('.autocomplete-list');

            input.addEventListener('input', () => {
                const val = input.value.toLowerCase();
                if (val.length < 1) {
                    list.classList.remove('visible');
                    return;
                }

                const matches = allItems.filter(item =>
                    item.id.toLowerCase().includes(val) ||
                    item.name.toLowerCase().includes(val)
                ).slice(0, 10);

                if (matches.length === 0) {
                    list.classList.remove('visible');
                    return;
                }

                list.innerHTML = matches.map(item => `
                <div class="autocomplete-item" data-id="${item.id}">
                    <div class="item-id">${item.id}</div>
                    <div class="item-name">${item.name}</div>
                </div>
            `).join('');

                list.classList.add('visible');
            });

            list.addEventListener('click', (e) => {
                const item = e.target.closest('.autocomplete-item');
                if (item) {
                    input.value = item.dataset.id;
                    list.classList.remove('visible');
                }
            });

            input.addEventListener('blur', () => {
                setTimeout(() => list.classList.remove('visible'), 200);
            });
        }

        // ========== NBT Load ==========
        function loadNBT(data) {
            const nbt = new NBTReader(data.buffer).parse();
            if (!nbt.palette || !nbt.blocks) throw new Error('Invalid NBT');

            const blocks = [];
            for (const b of nbt.blocks) {
                const state = b.state;
                if (state < nbt.palette.length) {
                    const name = nbt.palette[state].Name;
                    if (name && name !== 'minecraft:air' && name !== 'air') {
                        blocks.push([Number(b.pos[0]), Number(b.pos[1]), Number(b.pos[2]), name]);
                    }
                }
            }
            return blocks;
        }

        // ========== Sponge Schematic (.schem) Load ==========
        function loadSchem(data) {
            const nbt = new NBTReader(data.buffer).parse();

            // Sponge Schematic fields
            const width = nbt.Width;
            const height = nbt.Height;
            const length = nbt.Length;
            const palette = nbt.Palette;
            const blockData = nbt.BlockData;

            if (width === undefined || height === undefined || length === undefined || !palette || !blockData) {
                throw new Error('Invalid .schem file format: Missing required fields');
            }

            // Invert palette: ID -> Name
            const idToName = {};
            let maxId = 0;
            for (const [name, id] of Object.entries(palette)) {
                idToName[id] = name;
                if (id > maxId) maxId = id;
            }

            const blocks = [];
            let offset = 0;
            const totalBlocks = width * height * length;

            for (let i = 0; i < totalBlocks; i++) {
                // Read VarInt from blockData
                let value = 0;
                let shift = 0;
                while (true) {
                    if (offset >= blockData.length) break;
                    const byte = blockData[offset++];
                    value |= (byte & 0x7F) << shift;
                    shift += 7;
                    if ((byte & 0x80) === 0) break;
                }

                const blockId = value;
                const name = idToName[blockId];

                if (name && name !== 'minecraft:air' && name !== 'air' && !name.endsWith(':air')) {
                    // Index = (y * Length + z) * Width + x
                    const y = Math.floor(i / (width * length));
                    const rem = i % (width * length);
                    const z = Math.floor(rem / width);
                    const x = rem % width;

                    blocks.push([x, y, z, name]);
                }
            }
            return blocks;
        }

        // ========== WorldEdit (.we) Load ==========
        function loadWorldEdit(text) {
            // WorldEdit format: "5:return {{["z"] = 0, ["y"] = 0, ["name"] = "block:id", ["x"] = 0}, ...}"
            const blocks = [];

            // バージョン番号と"return"を除去してテーブル部分を取得
            const match = text.match(/^\d+:return\s*\{(.*)\}\s*$/s);
            if (!match) {
                throw new Error('Invalid WorldEdit format');
            }

            const tableContent = match[1];

            // 各ブロックエントリを抽出
            // パターン: {["z"] = 0, ["param2"] = 8, ["y"] = 0, ["param1"] = 15, ["name"] = "...", ["x"] = 0}
            let depth = 0;
            let start = -1;
            const entries = [];

            for (let i = 0; i < tableContent.length; i++) {
                const ch = tableContent[i];
                if (ch === '{') {
                    if (depth === 0) start = i;
                    depth++;
                } else if (ch === '}') {
                    depth--;
                    if (depth === 0 && start !== -1) {
                        entries.push(tableContent.substring(start + 1, i));
                        start = -1;
                    }
                }
            }

            for (const entry of entries) {
                // 各フィールドを抽出
                const xMatch = entry.match(/\["x"\]\s*=\s*(-?\d+)/);
                const yMatch = entry.match(/\["y"\]\s*=\s*(-?\d+)/);
                const zMatch = entry.match(/\["z"\]\s*=\s*(-?\d+)/);
                const nameMatch = entry.match(/\["name"\]\s*=\s*"([^"]+)"/);

                if (xMatch && yMatch && zMatch && nameMatch) {
                    const x = parseInt(xMatch[1]);
                    const y = parseInt(yMatch[1]);
                    const z = parseInt(zMatch[1]);
                    const name = nameMatch[1];

                    // param2（回転情報）があれば取得
                    const param2Match = entry.match(/\["param2"\]\s*=\s*(\d+)/);
                    const param2 = param2Match ? parseInt(param2Match[1]) : 0;

                    // airブロックはスキップ
                    if (name !== 'air' && !name.endsWith(':air')) {
                        blocks.push([x, y, z, name, param2]);
                    }
                }
            }

            if (blocks.length === 0) {
                throw new Error('No blocks found in WorldEdit file');
            }

            return blocks;
        }

        // ========== 3D Model Loader ==========
        let pendingMtlContent = null; // MTLファイルの内容を一時保存

        function load3DModel(file, mtlContent = null) {
            return new Promise((resolve, reject) => {
                const ext = file.name.split('.').pop().toLowerCase();
                const reader = new FileReader();

                reader.onload = (e) => {
                    try {
                        let geometry = null;

                        if (ext === 'obj') {
                            const objLoader = new THREE.OBJLoader();

                            // MTLがある場合はマテリアルを適用
                            if (mtlContent || pendingMtlContent) {
                                const mtlText = mtlContent || pendingMtlContent;

                                // MTLファイルの内容をチェック
                                const hasDirectColor = /^\s*Kd\s+[\d.]+\s+[\d.]+\s+[\d.]+/m.test(mtlText);
                                const hasTexture = /^\s*map_Kd\s+/m.test(mtlText);

                                if (hasTexture && !hasDirectColor) {
                                    log('警告: MTLファイルはテクスチャを参照していますが、テクスチャファイルは読み込めません', 'warning');
                                    log('色情報を取得するにはMTLファイルにKd（ディフューズカラー）を追加してください', 'warning');
                                }

                                const mtlLoader = new THREE.MTLLoader();
                                const materials = mtlLoader.parse(mtlText);
                                materials.preload();
                                objLoader.setMaterials(materials);

                                if (hasDirectColor) {
                                    log('MTLマテリアルを適用しました', 'success');
                                }
                                pendingMtlContent = null; // 使用後クリア
                            }

                            const obj = objLoader.parse(e.target.result);
                            geometry = mergeGeometries(obj);
                        } else if (ext === 'stl') {
                            const loader = new THREE.STLLoader();
                            geometry = loader.parse(e.target.result);

                        } else {
                            reject(new Error(`未対応のファイル形式: ${ext}`));
                            return;
                        }

                        if (!geometry) {
                            reject(new Error('ジオメトリの読み込みに失敗しました'));
                            return;
                        }

                        resolve(geometry);
                    } catch (err) {
                        reject(err);
                    }
                };

                reader.onerror = () => {
                    reject(new Error('ファイルの読み込みに失敗しました'));
                };

                if (ext === 'obj') {
                    reader.readAsText(file);
                } else {
                    reader.readAsArrayBuffer(file);
                }
            });
        }

        function mergeGeometries(object) {
            const geometries = [];
            let materialCount = 0;
            let meshCount = 0;
            const detectedColors = new Set();

            object.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    meshCount++;
                    const geom = child.geometry.clone();
                    child.updateWorldMatrix(true, false);
                    geom.applyMatrix4(child.matrixWorld);

                    // マテリアルから色を取得してジオメトリに頂点カラーとして追加
                    const pos = geom.getAttribute('position');
                    if (!geom.getAttribute('color') && pos) {
                        const colors = [];

                        // マテリアルが配列の場合（複数マテリアル）
                        if (Array.isArray(child.material)) {
                            // グループ情報を使って各頂点に色を割り当て
                            const groups = geom.groups;
                            if (groups && groups.length > 0) {
                                // 頂点ごとの色を初期化
                                for (let i = 0; i < pos.count; i++) {
                                    colors.push(0.5, 0.5, 0.5);
                                }
                                // グループごとに色を設定
                                for (const group of groups) {
                                    const mat = child.material[group.materialIndex];
                                    if (mat && mat.color) {
                                        const mc = mat.color;
                                        materialCount++;
                                        const r255 = Math.round(mc.r * 255);
                                        const g255 = Math.round(mc.g * 255);
                                        const b255 = Math.round(mc.b * 255);
                                        detectedColors.add(`RGB(${r255},${g255},${b255})`);
                                        for (let i = group.start; i < group.start + group.count; i++) {
                                            colors[i * 3] = mc.r;
                                            colors[i * 3 + 1] = mc.g;
                                            colors[i * 3 + 2] = mc.b;
                                        }
                                    }
                                }
                                geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                            } else {
                                // グループがない場合は最初のマテリアルを使用
                                const mat = child.material[0];
                                if (mat && mat.color) {
                                    const mc = mat.color;
                                    const isDefaultWhite = (mc.r === 1 && mc.g === 1 && mc.b === 1);
                                    if (!isDefaultWhite) {
                                        const r255 = Math.round(mc.r * 255);
                                        const g255 = Math.round(mc.g * 255);
                                        const b255 = Math.round(mc.b * 255);
                                        detectedColors.add(`RGB(${r255},${g255},${b255})`);
                                        for (let i = 0; i < pos.count; i++) {
                                            colors.push(mc.r, mc.g, mc.b);
                                        }
                                        geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                                    }
                                }
                            }
                        } else if (child.material && child.material.color) {
                            // 単一マテリアル
                            const mc = child.material.color;
                            const isDefaultWhite = (mc.r === 1 && mc.g === 1 && mc.b === 1);
                            if (!isDefaultWhite) {
                                materialCount++;
                                const r255 = Math.round(mc.r * 255);
                                const g255 = Math.round(mc.g * 255);
                                const b255 = Math.round(mc.b * 255);
                                detectedColors.add(`RGB(${r255},${g255},${b255})`);
                                for (let i = 0; i < pos.count; i++) {
                                    colors.push(mc.r, mc.g, mc.b);
                                }
                                geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                            }
                        }
                    }
                    geometries.push(geom);
                }
            });

            log(`メッシュ数: ${meshCount}, マテリアル適用数: ${materialCount}`);
            if (detectedColors.size > 0) {
                log(`検出された色: ${Array.from(detectedColors).join(', ')}`);
            }

            if (geometries.length === 0) throw new Error('No geometry found');
            if (geometries.length === 1) return geometries[0];

            const merged = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            let hasAnyColors = false;

            // まず色を持つジオメトリがあるか確認
            for (const geom of geometries) {
                if (geom.getAttribute('color')) {
                    hasAnyColors = true;
                    break;
                }
            }

            for (const geom of geometries) {
                const pos = geom.getAttribute('position');
                const col = geom.getAttribute('color');
                if (pos) {
                    for (let i = 0; i < pos.count; i++) {
                        positions.push(pos.getX(i), pos.getY(i), pos.getZ(i));
                        if (hasAnyColors) {
                            if (col) {
                                colors.push(col.getX(i), col.getY(i), col.getZ(i));
                            } else {
                                colors.push(0.5, 0.5, 0.5); // 色がないジオメトリはグレー
                            }
                        }
                    }
                }
            }
            merged.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            if (hasAnyColors && colors.length > 0) {
                merged.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            }
            return merged;
        }

        // ========== Auto Resolution ==========
        function calculateOptimalResolution(geometry, maxVoxels = 100000) {
            geometry.computeBoundingBox();
            const bbox = geometry.boundingBox;
            const sizeX = Math.max(bbox.max.x - bbox.min.x, 0.001);
            const sizeY = Math.max(bbox.max.y - bbox.min.y, 0.001);
            const sizeZ = Math.max(bbox.max.z - bbox.min.z, 0.001);
            const maxDim = Math.max(sizeX, sizeY, sizeZ);
            const volume = Math.max(sizeX * sizeY * sizeZ, 0.000001);

            // Calculate resolution to achieve approximately maxVoxels
            // volume / resolution^3 ≈ maxVoxels
            // resolution ≈ (volume / maxVoxels)^(1/3)
            let optimalRes = Math.pow(volume / maxVoxels, 1 / 3);

            // Ensure reasonable bounds: min 0.01, max = maxDim/5 (at least 5 voxels per axis)
            optimalRes = Math.max(0.01, Math.min(optimalRes, maxDim / 5));

            // Round to 2 decimal places
            optimalRes = Math.round(optimalRes * 100) / 100;
            if (optimalRes < 0.01) optimalRes = 0.01;

            return {
                resolution: optimalRes,
                modelSize: { x: sizeX.toFixed(2), y: sizeY.toFixed(2), z: sizeZ.toFixed(2) },
                maxDim: maxDim.toFixed(2),
                estimatedVoxels: Math.floor(volume / Math.pow(optimalRes, 3))
            };
        }

        // ========== Color to Block Mapping ==========
        // カテゴリ別カラーパレット
        const BLOCK_COLORS_WOOL = [
            { name: 'wool:white', r: 234, g: 236, b: 237 },
            { name: 'wool:orange', r: 241, g: 118, b: 20 },
            { name: 'wool:magenta', r: 190, g: 69, b: 180 },
            { name: 'wool:cyan', r: 22, g: 156, b: 157 },
            { name: 'wool:yellow', r: 254, g: 199, b: 31 },
            { name: 'wool:green', r: 112, g: 185, b: 26 },
            { name: 'wool:pink', r: 238, g: 141, b: 172 },
            { name: 'wool:grey', r: 63, g: 68, b: 72 },
            { name: 'wool:dark_grey', r: 142, g: 142, b: 135 },
            { name: 'wool:violet', r: 122, g: 42, b: 173 },
            { name: 'wool:blue', r: 53, g: 57, b: 157 },
            { name: 'wool:brown', r: 114, g: 72, b: 41 },
            { name: 'wool:dark_green', r: 84, g: 109, b: 28 },
            { name: 'wool:red', r: 161, g: 39, b: 35 },
            { name: 'wool:black', r: 21, g: 21, b: 26 },
        ];

        const BLOCK_COLORS_CONCRETE = [
            { name: 'concrete:concrete_white', r: 207, g: 213, b: 214 },
            { name: 'concrete:concrete_orange', r: 224, g: 97, b: 1 },
            { name: 'concrete:concrete_magenta', r: 170, g: 48, b: 159 },
            { name: 'concrete:concrete_cyan', r: 21, g: 119, b: 136 },
            { name: 'concrete:concrete_yellow', r: 241, g: 175, b: 21 },
            { name: 'concrete:concrete_green', r: 94, g: 169, b: 25 },
            { name: 'concrete:concrete_pink', r: 214, g: 101, b: 143 },
            { name: 'concrete:concrete_grey', r: 55, g: 58, b: 62 },
            { name: 'concrete:concrete_dark_grey', r: 125, g: 125, b: 115 },
            { name: 'concrete:concrete_violet', r: 100, g: 32, b: 156 },
            { name: 'concrete:concrete_blue', r: 45, g: 47, b: 143 },
            { name: 'concrete:concrete_brown', r: 96, g: 60, b: 32 },
            { name: 'concrete:concrete_dark_green', r: 73, g: 91, b: 36 },
            { name: 'concrete:concrete_red', r: 142, g: 33, b: 33 },
            { name: 'concrete:concrete_black', r: 8, g: 10, b: 15 },
        ];

        const BLOCK_COLORS_TERRACOTTA = [
            { name: 'hardened_clay:white', r: 210, g: 178, b: 161 },
            { name: 'hardened_clay:orange', r: 162, g: 84, b: 38 },
            { name: 'hardened_clay:magenta', r: 150, g: 88, b: 109 },
            { name: 'hardened_clay:cyan', r: 87, g: 91, b: 91 },
            { name: 'hardened_clay:yellow', r: 186, g: 133, b: 35 },
            { name: 'hardened_clay:green', r: 104, g: 118, b: 53 },
            { name: 'hardened_clay:pink', r: 162, g: 78, b: 79 },
            { name: 'hardened_clay:grey', r: 58, g: 42, b: 36 },
            { name: 'hardened_clay:dark_grey', r: 135, g: 107, b: 98 },
            { name: 'hardened_clay:violet', r: 118, g: 70, b: 86 },
            { name: 'hardened_clay:blue', r: 74, g: 60, b: 91 },
            { name: 'hardened_clay:brown', r: 77, g: 51, b: 36 },
            { name: 'hardened_clay:dark_green', r: 76, g: 83, b: 42 },
            { name: 'hardened_clay:red', r: 143, g: 61, b: 47 },
            { name: 'hardened_clay:black', r: 37, g: 23, b: 17 },
        ];

        const BLOCK_COLORS_GLASS = [
            { name: 'default:glass', r: 230, g: 230, b: 230 },
            { name: 'default:glass_white', r: 240, g: 240, b: 240 },
            { name: 'default:glass_orange', r: 255, g: 200, b: 100 },
            { name: 'default:glass_magenta', r: 200, g: 100, b: 200 },
            { name: 'default:glass_cyan', r: 127, g: 221, b: 212 },
            { name: 'default:glass_yellow', r: 255, g: 255, b: 150 },
            { name: 'default:glass_green', r: 173, g: 255, b: 47 },
            { name: 'default:glass_pink', r: 255, g: 182, b: 193 },
            { name: 'default:glass_grey', r: 150, g: 150, b: 150 },
            { name: 'default:glass_dark_grey', r: 80, g: 80, b: 80 },
            { name: 'default:glass_violet', r: 147, g: 112, b: 219 },
            { name: 'default:glass_blue', r: 107, g: 138, b: 201 },
            { name: 'default:glass_brown', r: 120, g: 80, b: 50 },
            { name: 'default:glass_dark_green', r: 50, g: 100, b: 50 },
            { name: 'default:glass_red', r: 200, g: 50, b: 50 },
            { name: 'default:glass_black', r: 30, g: 30, b: 30 },
        ];

        const BLOCK_COLORS_OTHER = [
            { name: 'default:stone', r: 125, g: 125, b: 125 },
            { name: 'default:cobble', r: 100, g: 100, b: 100 },
            { name: 'default:dirt', r: 134, g: 96, b: 67 },
            { name: 'default:sand', r: 219, g: 211, b: 160 },
            { name: 'default:gravel', r: 136, g: 126, b: 126 },
            { name: 'default:clay', r: 159, g: 164, b: 177 },
            { name: 'default:sandstone', r: 218, g: 210, b: 158 },
            { name: 'default:brick', r: 150, g: 97, b: 83 },
            { name: 'default:obsidian', r: 15, g: 11, b: 25 },
            { name: 'default:goldblock', r: 249, g: 236, b: 79 },
            { name: 'default:steelblock', r: 230, g: 230, b: 230 },
            { name: 'default:copperblock', r: 192, g: 108, b: 80 },
            { name: 'default:wood', r: 162, g: 131, b: 79 },
            { name: 'default:tree', r: 111, g: 91, b: 54 },
            { name: 'default:leaves', r: 58, g: 93, b: 40 },
            { name: 'default:ice', r: 175, g: 215, b: 253 },
            { name: 'default:snowblock', r: 249, g: 254, b: 254 },
            { name: 'default:quartz_block', r: 235, g: 230, b: 220 },
            { name: 'default:emeraldblock', r: 50, g: 200, b: 100 },
            { name: 'default:rubyblock', r: 200, g: 50, b: 80 },
            { name: 'default:diamondblock', r: 100, g: 220, b: 255 },
            { name: 'amethyst_geode:amethyst_block', r: 150, g: 100, b: 200 },
            { name: 'charoite:block', r: 140, g: 80, b: 180 },
            { name: 'bluestone_stickyblocks:slimeblock', r: 120, g: 200, b: 80 },
            { name: 'pink_biome:cherry_blossom_leaves', r: 255, g: 180, b: 200 },
            { name: 'pink_biome:cherry_blossom_wood', r: 180, g: 130, b: 120 },
        ];

        // すべてのカラーブロックを結合
        const BLOCK_COLORS_ALL = [
            ...BLOCK_COLORS_WOOL,
            ...BLOCK_COLORS_CONCRETE,
            ...BLOCK_COLORS_TERRACOTTA,
            ...BLOCK_COLORS_GLASS,
            ...BLOCK_COLORS_OTHER,
        ];

        function getBlockColorPalette(mode) {
            switch (mode) {
                case 'wool': return BLOCK_COLORS_WOOL;
                case 'concrete': return BLOCK_COLORS_CONCRETE;
                case 'terracotta': return BLOCK_COLORS_TERRACOTTA;
                case 'glass': return BLOCK_COLORS_GLASS;
                case 'all': return BLOCK_COLORS_ALL;
                default: return [];
            }
        }

        function colorDistance(r1, g1, b1, r2, g2, b2) {
            // CIE76に近似した色差計算（人間の目に近い）
            const dr = r1 - r2, dg = g1 - g2, db = b1 - b2;
            // 赤の重み付けを調整（人間の目は緑に敏感、青に鈍感）
            const rMean = (r1 + r2) / 2;
            const weightR = rMean < 128 ? 2 : 3;
            const weightG = 4;
            const weightB = rMean < 128 ? 3 : 2;
            return Math.sqrt(weightR * dr * dr + weightG * dg * dg + weightB * db * db);
        }

        function findNearestBlock(r, g, b, mode = 'all') {
            if (mode === 'single') {
                return document.getElementById('blockId').value || 'default:stone';
            }

            const palette = getBlockColorPalette(mode);
            if (palette.length === 0) {
                return document.getElementById('blockId').value || 'default:stone';
            }

            let minDist = Infinity;
            let nearest = palette[0].name;
            for (const block of palette) {
                const dist = colorDistance(r, g, b, block.r, block.g, block.b);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = block.name;
                }
            }
            return nearest;
        }

        // 後方互換性のため
        function findNearestWool(r, g, b) {
            return findNearestBlock(r, g, b, 'all');
        }

        // ========== Voxelization ==========
        function voxelizeMesh(geometry, resolution, colorMode = 'all') {
            log(`ボクセル化中 (解像度: ${resolution}, 色モード: ${colorMode})...`);
            geometry.computeBoundingBox();
            const bbox = geometry.boundingBox;
            const minX = bbox.min.x, minY = bbox.min.y, minZ = bbox.min.z;
            const maxX = bbox.max.x, maxY = bbox.max.y, maxZ = bbox.max.z;
            const sizeX = Math.ceil((maxX - minX) / resolution);
            const sizeY = Math.ceil((maxY - minY) / resolution);
            const sizeZ = Math.ceil((maxZ - minZ) / resolution);
            log(`グリッドサイズ: ${sizeX} x ${sizeY} x ${sizeZ}`);

            const positions = geometry.getAttribute('position');
            const colors = geometry.getAttribute('color'); // 頂点カラーを取得
            const hasColors = colors !== null && colors !== undefined;

            // 単一ブロックモードの場合は色情報を無視
            const useColors = hasColors && colorMode !== 'single';

            if (useColors) {
                const modeNames = {
                    'wool': 'ウール',
                    'concrete': 'コンクリート',
                    'hardened_clay': 'テラコッタ',
                    'glass': 'ガラス',
                    'all': 'すべてのカラーブロック'
                };
                log(`頂点カラーを検出 - ${modeNames[colorMode] || colorMode}で色付けします`, 'success');
                // サンプルとして最初の頂点の色をログ出力
                if (colors.count > 0) {
                    const sampleR = Math.round(colors.getX(0) * 255);
                    const sampleG = Math.round(colors.getY(0) * 255);
                    const sampleB = Math.round(colors.getZ(0) * 255);
                    log(`サンプル色: RGB(${sampleR}, ${sampleG}, ${sampleB})`);
                }
            } else if (colorMode === 'single') {
                log('単一ブロックモード - 指定したブロックIDを使用します');
            } else {
                log('頂点カラーなし - 単一ブロックIDを使用します');
                // デバッグ: 利用可能な属性を表示
                const attrs = Object.keys(geometry.attributes);
                log(`利用可能な属性: ${attrs.join(', ') || 'position のみ'}`);
            }

            const triangles = [];
            for (let i = 0; i < positions.count; i += 3) {
                const tri = {
                    v0: new THREE.Vector3(positions.getX(i), positions.getY(i), positions.getZ(i)),
                    v1: new THREE.Vector3(positions.getX(i + 1), positions.getY(i + 1), positions.getZ(i + 1)),
                    v2: new THREE.Vector3(positions.getX(i + 2), positions.getY(i + 2), positions.getZ(i + 2))
                };
                if (useColors) {
                    // 三角形の平均色を計算
                    tri.r = Math.round(((colors.getX(i) + colors.getX(i + 1) + colors.getX(i + 2)) / 3) * 255);
                    tri.g = Math.round(((colors.getY(i) + colors.getY(i + 1) + colors.getY(i + 2)) / 3) * 255);
                    tri.b = Math.round(((colors.getZ(i) + colors.getZ(i + 1) + colors.getZ(i + 2)) / 3) * 255);
                }
                triangles.push(tri);
            }
            log(`三角形数: ${triangles.length}`);

            const voxels = new Map(); // key -> { x, y, z, blockId }
            for (const tri of triangles) {
                const samples = sampleTriangle(tri.v0, tri.v1, tri.v2, resolution / 2);
                const blockId = useColors ? findNearestBlock(tri.r, tri.g, tri.b, colorMode) : null;
                for (const p of samples) {
                    const vx = Math.floor((p.x - minX) / resolution);
                    const vy = Math.floor((p.y - minY) / resolution);
                    const vz = Math.floor((p.z - minZ) / resolution);
                    const key = `${vx},${vy},${vz}`;
                    if (!voxels.has(key)) {
                        voxels.set(key, { x: vx, y: vy, z: vz, blockId: blockId });
                    }
                }
            }

            const result = [];
            for (const voxel of voxels.values()) {
                result.push([voxel.x, voxel.y, voxel.z, voxel.blockId]);
            }
            log(`ボクセル数: ${result.length}`, 'success');
            if (useColors) {
                const colorStats = {};
                for (const v of result) {
                    if (v[3]) colorStats[v[3]] = (colorStats[v[3]] || 0) + 1;
                }
                log(`使用ブロック: ${Object.keys(colorStats).join(', ')}`);
            }
            return result;
        }

        function sampleTriangle(v0, v1, v2, step) {
            const points = [];
            const edge1 = new THREE.Vector3().subVectors(v1, v0);
            const edge2 = new THREE.Vector3().subVectors(v2, v0);
            const cross = new THREE.Vector3().crossVectors(edge1, edge2);
            const area = cross.length() / 2;
            // Cap samples at 100 to prevent memory explosion on large triangles
            const numSamples = Math.min(100, Math.max(1, Math.ceil(area / (step * step))));
            for (let i = 0; i <= numSamples; i++) {
                for (let j = 0; j <= numSamples - i; j++) {
                    const u = i / numSamples, v = j / numSamples, w = 1 - u - v;
                    points.push(new THREE.Vector3(
                        w * v0.x + u * v1.x + v * v2.x,
                        w * v0.y + u * v1.y + v * v2.y,
                        w * v0.z + u * v1.z + v * v2.z
                    ));
                }
            }
            return points;
        }

        function generate3DModelCommands(voxels, defaultBlockId, scale = 1) {
            const commands = [];
            let pos = [0, 0, 0];
            let lastBlockId = null;
            const sorted = [...voxels].sort((a, b) => {
                if (a[1] !== b[1]) return a[1] - b[1];
                if (a[2] !== b[2]) return a[2] - b[2];
                return a[0] - b[0];
            });
            for (let i = 0; i < sorted.length; i++) {
                const [x, y, z, colorBlockId] = sorted[i];
                const blockId = colorBlockId || defaultBlockId;
                const axes = ['x', 'y', 'z'];
                const target = [x, y, z];
                for (let j = 0; j < 3; j++) {
                    const diff = Math.floor(target[j] * scale - pos[j] * scale);
                    if (diff !== 0) {
                        commands.push(`/shift ${axes[j]} ${diff}`);
                        pos[j] = target[j];
                    }
                }
                commands.push(`/s ${blockId}`);
                if (i % 1000 === 0) setProgress(Math.floor((i / sorted.length) * 100));
            }
            return commands;
        }

        // ========== Commands ==========
        function generateCommands(blocks, scale = 1) {
            const commands = [];
            let pos = [0, 0, 0];
            let skipped = 0;

            const sorted = [...blocks].sort((a, b) => {
                if (a[1] !== b[1]) return a[1] - b[1];
                if (a[2] !== b[2]) return a[2] - b[2];
                return a[0] - b[0];
            });

            for (let i = 0; i < sorted.length; i++) {
                const block = sorted[i];
                const [x, y, z, name] = block;

                let cmd, param2;
                if (isWorldEdit) {
                    // WorldEdit形式: ブロックIDはそのまま使用、param2は5番目の要素
                    cmd = name;
                    param2 = block[4] || 0;
                } else {
                    // Minecraft形式: マッピングを通す
                    [cmd, param2] = getMulticraftBlock(name);
                }
                if (cmd === null) { skipped++; continue; }

                const axes = ['x', 'y', 'z'];
                const target = [x, y, z];
                for (let j = 0; j < 3; j++) {
                    const diff = Math.floor(target[j] * scale - pos[j] * scale);
                    if (diff !== 0) {
                        commands.push(`/shift ${axes[j]} ${diff}`);
                        pos[j] = target[j];
                    }
                }
                commands.push(`/s ${cmd}`);
                if (param2 !== 0) commands.push(`/param2 ${param2}`);
                if (i % 1000 === 0) setProgress(Math.floor((i / sorted.length) * 100));
            }

            if (skipped > 0) log(`スキップ: ${skipped}`, 'warning');
            return commands;
        }

        // ========== Save ==========
        function saveCommands(commands, baseName) {
            const maxLines = parseInt(document.getElementById('maxLines').value) || 30000;
            downloadArea.innerHTML = '';

            if (commands.length > maxLines) {
                const n = Math.ceil(commands.length / maxLines);
                for (let i = 0; i < n; i++) {
                    const chunk = commands.slice(i * maxLines, Math.min((i + 1) * maxLines, commands.length));
                    createLink(chunk, `${baseName}_part${i + 1}.txt`);
                }
            } else {
                createLink(commands, `${baseName}.txt`);
            }
        }

        function createLink(commands, fileName) {
            const commandText = commands.join('\n');
            const blob = new Blob([commandText], { type: 'text/plain' });

            // コンテナを作成
            const item = document.createElement('div');
            item.className = 'download-item';

            // ヘッダー（ファイル名とコマンド数）
            const header = document.createElement('div');
            header.className = 'download-item-header';
            header.textContent = `${fileName} (${commands.length}コマンド)`;
            item.appendChild(header);

            // ボタンコンテナ
            const buttons = document.createElement('div');
            buttons.className = 'download-buttons';

            // ダウンロードリンク
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            link.className = 'download-link';
            link.textContent = 'ダウンロード';
            buttons.appendChild(link);

            // コピーボタン
            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.textContent = 'コピー';
            copyBtn.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(commandText);
                    copyBtn.textContent = 'コピー完了！';
                    copyBtn.classList.add('copied');
                    log(`コピーしました: ${fileName}`, 'success');
                    setTimeout(() => {
                        copyBtn.textContent = 'コピー';
                        copyBtn.classList.remove('copied');
                    }, 2000);
                } catch (err) {
                    log(`コピー失敗: ${err.message}`, 'error');
                }
            });
            buttons.appendChild(copyBtn);

            item.appendChild(buttons);

            // コマンドプレビュー
            const preview = document.createElement('div');
            preview.className = 'command-preview';

            const previewHeader = document.createElement('div');
            previewHeader.className = 'command-preview-header';
            previewHeader.innerHTML = `
                <span class="command-preview-title">コマンドプレビュー (${commands.length}行)</span>
                <span class="command-preview-toggle">▼ 展開</span>
            `;

            const previewContent = document.createElement('div');
            previewContent.className = 'command-preview-content collapsed';

            // コマンドを構文ハイライト付きで表示（最大500行）
            const displayCommands = commands.slice(0, 500);
            previewContent.innerHTML = displayCommands.map(cmd => {
                let highlighted = cmd
                    .replace(/(\/shift)/g, '<span class="cmd-shift">$1</span>')
                    .replace(/(\/s\s)/g, '<span class="cmd-set">$1</span>')
                    .replace(/(\/param2\s+\d+)/g, '<span class="cmd-param">$1</span>');
                return `<span class="cmd-line">${highlighted}</span>`;
            }).join('') + (commands.length > 500 ? `<span class="cmd-line" style="color:#888">... 他${commands.length - 500}行</span>` : '');

            previewHeader.addEventListener('click', () => {
                const isCollapsed = previewContent.classList.toggle('collapsed');
                previewHeader.querySelector('.command-preview-toggle').textContent = isCollapsed ? '▼ 展開' : '▲ 折りたたむ';
            });

            preview.appendChild(previewHeader);
            preview.appendChild(previewContent);
            item.appendChild(preview);

            downloadArea.appendChild(item);
            log(`準備完了: ${fileName}`, 'success');
        }

        // ========== Unknown Blocks ==========
        function findUnknown(blocks) {
            const unknown = {};
            for (const b of blocks) {
                let [base] = parseBlockState(b[3].toLowerCase());
                if (!base.startsWith('minecraft:')) base = 'minecraft:' + base;
                if (BLOCK_MAPPING[base] === undefined && !unknown[base]) {
                    unknown[base] = blocks.filter(x => {
                        let [n] = parseBlockState(x[3].toLowerCase());
                        if (!n.startsWith('minecraft:')) n = 'minecraft:' + n;
                        return n === base;
                    }).length;
                }
            }
            return unknown;
        }

        function renderUnknownBlocks(unknown) {
            if (Object.keys(unknown).length === 0) {
                unknownList.innerHTML = '<div class="empty-state">未対応ブロックなし</div>';
                return;
            }

            const sorted = Object.entries(unknown).sort((a, b) => b[1] - a[1]);
            unknownList.innerHTML = sorted.map(([name, count]) => {
                const fallback = name.replace('minecraft:', 'default:');
                return `
                <div class="unknown-item">
                    <div>
                        <div class="unknown-name">${name}</div>
                        <div class="unknown-count">${count}個</div>
                    </div>
                    <div class="autocomplete-wrapper">
                        <input type="text" class="unknown-input" data-block="${name}" placeholder="${fallback}">
                        <div class="autocomplete-list"></div>
                    </div>
                </div>
            `;
            }).join('');

            unknownList.querySelectorAll('.unknown-input').forEach(setupAutocomplete);
        }

        function collectMappings() {
            userMappings = {};
            for (const input of unknownList.querySelectorAll('.unknown-input')) {
                const name = input.dataset.block;
                const val = input.value.trim();
                if (val === '') userMappings[name] = name.replace('minecraft:', 'default:');
                else if (val.toLowerCase() === 'air') userMappings[name] = null;
                else userMappings[name] = val;
            }
        }

        // ========== Process ==========
        async function processFiles(files) {
            // 複数ファイルの場合（OBJ+MTL）を処理
            const fileList = Array.from(files);
            let objFile = null;
            let mtlFile = null;
            let otherFile = null;

            for (const file of fileList) {
                const ext = file.name.split('.').pop().toLowerCase();
                if (ext === 'obj') objFile = file;
                else if (ext === 'mtl') mtlFile = file;
                else otherFile = file;
            }

            // MTLファイルがある場合は先に読み込む
            if (mtlFile) {
                log(`MTLファイル読み込み: ${mtlFile.name}`);
                const mtlText = await mtlFile.text();
                pendingMtlContent = mtlText;
            }

            // メインファイルを処理
            const mainFile = objFile || otherFile || fileList[0];
            if (mainFile) {
                await processFile(mainFile);
            }
        }

        async function processFile(file) {
            try {
                userResolutionLocked = false;
                currentGeometry = null;
                isWorldEdit = false;
                currentFileName = file.name;
                const ext = file.name.split('.').pop().toLowerCase();
                log(`読み込み: ${file.name}`);
                updateStatus('fileName', file.name);
                setProgress(0);

                if (['obj', 'stl'].includes(ext)) {
                    is3DModel = true;
                    log('3Dモデルを読み込み中...', 'success');
                    const geometry = await load3DModel(file);
                    currentGeometry = geometry;

                    // Calculate optimal resolution based on model size
                    const autoRes = calculateOptimalResolution(geometry);
                    log(`モデルサイズ: ${autoRes.modelSize.x} x ${autoRes.modelSize.y} x ${autoRes.modelSize.z}`);
                    log(`推奨解像度: ${autoRes.resolution} (推定ボクセル数: ${autoRes.estimatedVoxels.toLocaleString()})`);

                    const resInput = resolutionInput;
                    if (!userResolutionLocked) {
                        // Refresh to the auto value for each new file unless the user explicitly typed a value
                        resInput.value = autoRes.resolution;
                    }

                    const userRes = parseFloat(resInput.value);
                    let resolution = autoRes.resolution;
                    if (userResolutionLocked && userRes && userRes > 0) {
                        const bbox = geometry.boundingBox;
                        const estVoxels = ((bbox.max.x - bbox.min.x) / userRes) *
                            ((bbox.max.y - bbox.min.y) / userRes) *
                            ((bbox.max.z - bbox.min.z) / userRes);
                        if (estVoxels > 500000) {
                            log(`警告: ユーザー設定の解像度 ${userRes} だと約${Math.floor(estVoxels).toLocaleString()}ボクセルになります`, 'warning');
                            log(`自動調整された解像度 ${autoRes.resolution} を使用します`, 'warning');
                        } else {
                            resolution = userRes;
                        }
                    }

                    // Update UI with actual resolution used for this file
                    resInput.value = resolution;

                    const colorMode = document.getElementById('colorMode').value;
                    current3DVoxels = voxelizeMesh(geometry, resolution, colorMode);
                    currentBlocks = [];
                    updateStatus('blockCount', current3DVoxels.length);
                    update3DSettingsVisibility();
                    convertBtn.disabled = false;
                    previewBtn.disabled = false;
                } else if (ext === 'we') {
                    // WorldEdit形式
                    is3DModel = false;
                    isWorldEdit = true;
                    update3DSettingsVisibility();
                    const text = await file.text();
                    currentBlocks = loadWorldEdit(text);
                    current3DVoxels = [];
                    updateStatus('blockCount', currentBlocks.length);
                    log(`WorldEditファイル読み込み: ${currentBlocks.length}ブロック`, 'success');
                    // WorldEdit形式はブロックIDがそのまま使えるので未対応チェック不要
                    unknownBlocks = {};
                    updateSettingsVisibility();
                    convertBtn.disabled = false;
                    previewBtn.disabled = false;
                    convertBtn.disabled = false;
                    previewBtn.disabled = false;
                } else if (ext === 'schem') {
                    // Sponge Schematic (.schem)
                    is3DModel = false;
                    isWorldEdit = false;
                    update3DSettingsVisibility();
                    const buf = await file.arrayBuffer();
                    let data;
                    try { data = pako.inflate(new Uint8Array(buf)); }
                    catch { data = new Uint8Array(buf); }

                    try {
                        currentBlocks = loadSchem(data);
                        current3DVoxels = [];
                        updateStatus('blockCount', currentBlocks.length);
                        log(`Schematicファイル読み込み: ${currentBlocks.length}ブロック`, 'success');
                        unknownBlocks = findUnknown(currentBlocks);
                        if (Object.keys(unknownBlocks).length > 0) {
                            renderUnknownBlocks(unknownBlocks);
                            log(`未対応: ${Object.keys(unknownBlocks).length}種類`, 'warning');
                            updateSettingsVisibility();
                        }
                        convertBtn.disabled = false;
                        previewBtn.disabled = false;
                    } catch (e) {
                        log(`Schematic読み込みエラー: ${e.message}`, 'error');
                        throw e;
                    }
                } else {
                    is3DModel = false;
                    isWorldEdit = false;
                    update3DSettingsVisibility();
                    const buf = await file.arrayBuffer();
                    let data;
                    try { data = pako.inflate(new Uint8Array(buf)); }
                    catch { data = new Uint8Array(buf); }
                    currentBlocks = loadNBT(data);
                    current3DVoxels = [];
                    updateStatus('blockCount', currentBlocks.length);
                    log(`ブロック: ${currentBlocks.length}`, 'success');
                    unknownBlocks = findUnknown(currentBlocks);

                    // 未対応ブロックがあればモーダルを表示
                    if (Object.keys(unknownBlocks).length > 0) {
                        renderUnknownBlocks(unknownBlocks);
                        log(`未対応: ${Object.keys(unknownBlocks).length}種類`, 'warning');
                        updateSettingsVisibility();
                    }
                    convertBtn.disabled = false;
                    previewBtn.disabled = false;
                }
            } catch (e) {
                log(`エラー: ${e.message}`, 'error');
                console.error(e);
            }
        }

        function doConvert() {
            const scale = parseInt(document.getElementById('scale').value) || 1;
            let commands;
            if (is3DModel) {
                if (!currentGeometry) {
                    log('3Dモデルが読み込まれていません', 'error');
                    return;
                }

                // Recalculate resolution at conversion time in case the user edited the value after load
                const autoRes = calculateOptimalResolution(currentGeometry);
                const resInput = resolutionInput;
                if (!userResolutionLocked) {
                    resInput.value = autoRes.resolution;
                }

                const userRes = parseFloat(resInput.value);
                let resolution = autoRes.resolution;
                if (userRes && userRes > 0) {
                    if (!currentGeometry.boundingBox) currentGeometry.computeBoundingBox();
                    const bbox = currentGeometry.boundingBox;
                    const estVoxels = ((bbox.max.x - bbox.min.x) / userRes) *
                        ((bbox.max.y - bbox.min.y) / userRes) *
                        ((bbox.max.z - bbox.min.z) / userRes);
                    if (estVoxels > 500000) {
                        log(`警告: ユーザー設定の解像度 ${userRes} だと約${Math.floor(estVoxels).toLocaleString()}ボクセルになります`, 'warning');
                        log(`自動調整された解像度 ${autoRes.resolution} を使用します`, 'warning');
                    } else {
                        resolution = userRes;
                    }
                }
                resInput.value = resolution;

                const colorMode = document.getElementById('colorMode').value;
                current3DVoxels = voxelizeMesh(currentGeometry, resolution, colorMode);
                updateStatus('blockCount', current3DVoxels.length);

                const blockId = document.getElementById('blockId').value || 'default:stone';
                commands = generate3DModelCommands(current3DVoxels, blockId, scale);
            } else {
                collectMappings();
                commands = generateCommands(currentBlocks, scale);
            }
            updateStatus('commandCount', commands.length);
            setProgress(100);
            saveCommands(commands, currentFileName.replace(/\.[^.]+$/, ''));
            log(`完了: ${commands.length}コマンド`, 'success');
        }

        // ========== Events ==========
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', e => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                processFiles(e.dataTransfer.files);
            }
        });
        fileInput.addEventListener('change', e => {
            if (e.target.files.length > 0) {
                processFiles(e.target.files);
            }
        });
        convertBtn.addEventListener('click', doConvert);

        // ========== 3D Preview ==========
        const previewBtn = document.getElementById('previewBtn');
        const previewModal = document.getElementById('previewModal');
        const previewClose = document.getElementById('previewClose');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewInfo = document.getElementById('previewInfo');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const toggleWireBtn = document.getElementById('toggleWireBtn');

        let previewScene, previewCamera, previewRenderer, previewMesh;
        let previewCtrl = { drag: false, lx: 0, ly: 0, rx: 0.5, ry: 0.5, zoom: 1 };
        let wireMode = false, animId = null;

        function initPreview() {
            previewScene = new THREE.Scene();
            previewScene.background = new THREE.Color(0x1a1a1a);
            const c = previewCanvas.parentElement;
            previewCamera = new THREE.PerspectiveCamera(60, c.clientWidth / c.clientHeight, 0.1, 10000);
            previewCamera.position.set(0, 0, 100);
            previewRenderer = new THREE.WebGLRenderer({ canvas: previewCanvas, antialias: true });
            previewRenderer.setSize(c.clientWidth, c.clientHeight);
            previewRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            previewScene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const d1 = new THREE.DirectionalLight(0xffffff, 0.6); d1.position.set(1, 1, 1); previewScene.add(d1);
            const d2 = new THREE.DirectionalLight(0xffffff, 0.3); d2.position.set(-1, -1, -1); previewScene.add(d2);
        }

        function createVoxels(vox, isNBT) {
            if (previewMesh) { previewScene.remove(previewMesh); previewMesh.geometry?.dispose(); previewMesh.material?.dispose(); }
            if (!vox.length) return;
            let mnX = Infinity, mnY = Infinity, mnZ = Infinity, mxX = -Infinity, mxY = -Infinity, mxZ = -Infinity;
            for (const v of vox) {
                const x = v[0], y = v[1], z = v[2];
                mnX = Math.min(mnX, x); mxX = Math.max(mxX, x);
                mnY = Math.min(mnY, y); mxY = Math.max(mxY, y);
                mnZ = Math.min(mnZ, z); mxZ = Math.max(mxZ, z);
            }
            const cx = (mnX + mxX) / 2, cy = (mnY + mxY) / 2, cz = (mnZ + mxZ) / 2, sz = Math.max(mxX - mnX, mxY - mnY, mxZ - mnZ) + 1;
            const geo = new THREE.BoxGeometry(0.95, 0.95, 0.95);

            // Check if any voxel has color data (blockId) - only for 3D models
            const hasColorData = !isNBT && vox.some(v => v[3] !== null && v[3] !== undefined);

            let mat, mesh;
            if (hasColorData) {
                // Use instance colors for colored voxels
                mat = new THREE.MeshLambertMaterial({ wireframe: wireMode });
                mesh = new THREE.InstancedMesh(geo, mat, vox.length);

                const m = new THREE.Matrix4();
                const colors = [];
                for (let i = 0; i < vox.length; i++) {
                    const v = vox[i];
                    const x = v[0], y = v[1], z = v[2], blockId = v[3];
                    m.setPosition(x - cx, y - cy, z - cz);
                    mesh.setMatrixAt(i, m);

                    // Find color from blockId
                    let r = 0.3, g = 0.5, b = 0.8; // Default blue
                    if (blockId) {
                        const block = BLOCK_COLORS_ALL.find(bc => bc.name === blockId);
                        if (block) {
                            r = block.r / 255;
                            g = block.g / 255;
                            b = block.b / 255;
                        }
                    }
                    colors.push(r, g, b);
                }
                // Set instance colors using InstancedBufferAttribute
                mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(colors), 3);
                mesh.instanceColor.needsUpdate = true;
                mat.needsUpdate = true;
            } else {
                // Single color for NBT or non-colored 3D models
                mat = new THREE.MeshLambertMaterial({ color: 0x4a90d9, wireframe: wireMode });
                mesh = new THREE.InstancedMesh(geo, mat, vox.length);
                const m = new THREE.Matrix4();
                for (let i = 0; i < vox.length; i++) {
                    const v = vox[i];
                    const x = v[0], y = v[1], z = v[2];
                    m.setPosition(x - cx, y - cy, z - cz);
                    mesh.setMatrixAt(i, m);
                }
            }

            mesh.instanceMatrix.needsUpdate = true;
            previewScene.add(mesh); previewMesh = mesh;
            previewCamera.position.set(0, 0, sz * 1.5); previewCamera.lookAt(0, 0, 0);
            previewCtrl.zoom = 1; previewCtrl.rx = 0.5; previewCtrl.ry = 0.5;
            previewInfo.textContent = `${vox.length.toLocaleString()} ボクセル | ${Math.ceil(mxX - mnX + 1)}x${Math.ceil(mxY - mnY + 1)}x${Math.ceil(mxZ - mnZ + 1)}`;
        }

        function renderLoop() {
            if (!previewMesh) return;
            previewMesh.rotation.x = previewCtrl.ry * Math.PI;
            previewMesh.rotation.y = previewCtrl.rx * Math.PI;
            previewRenderer.render(previewScene, previewCamera);
            animId = requestAnimationFrame(renderLoop);
        }

        function openPreview() {
            if (!previewScene) initPreview();
            const vox = is3DModel ? current3DVoxels : currentBlocks;
            if (!vox.length) { log('プレビューするデータがありません', 'error'); return; }
            const maxVox = 100000;
            let pv = vox.length > maxVox ? (log(`プレビューを${maxVox}に制限`, 'warning'), vox.slice(0, maxVox)) : vox;
            createVoxels(pv, !is3DModel);
            previewModal.classList.add('active');
            const c = previewCanvas.parentElement;
            previewRenderer.setSize(c.clientWidth, c.clientHeight);
            previewCamera.aspect = c.clientWidth / c.clientHeight;
            previewCamera.updateProjectionMatrix();
            renderLoop();
        }

        function closePreview() {
            previewModal.classList.remove('active');
            if (animId) { cancelAnimationFrame(animId); animId = null; }
        }

        previewCanvas.addEventListener('mousedown', e => { previewCtrl.drag = true; previewCtrl.lx = e.clientX; previewCtrl.ly = e.clientY; });
        previewCanvas.addEventListener('mousemove', e => {
            if (!previewCtrl.drag) return;
            previewCtrl.rx += (e.clientX - previewCtrl.lx) * 0.005;
            previewCtrl.ry += (e.clientY - previewCtrl.ly) * 0.005;
            previewCtrl.lx = e.clientX; previewCtrl.ly = e.clientY;
        });
        previewCanvas.addEventListener('mouseup', () => previewCtrl.drag = false);
        previewCanvas.addEventListener('mouseleave', () => previewCtrl.drag = false);
        previewCanvas.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
            previewCamera.position.z *= zoomFactor;
            previewCamera.position.z = Math.max(1, Math.min(10000, previewCamera.position.z));
        });

        previewBtn.addEventListener('click', openPreview);
        previewClose.addEventListener('click', closePreview);
        resetViewBtn.addEventListener('click', () => {
            previewCtrl.rx = 0.5;
            previewCtrl.ry = 0.5;
            if (previewMesh) {
                const vox = is3DModel ? current3DVoxels : currentBlocks;
                if (vox.length > 0) {
                    let mxX = -Infinity, mxY = -Infinity, mxZ = -Infinity, mnX = Infinity, mnY = Infinity, mnZ = Infinity;
                    for (const v of vox) {
                        const [x, y, z] = is3DModel ? v : [v[0], v[1], v[2]];
                        mnX = Math.min(mnX, x); mxX = Math.max(mxX, x);
                        mnY = Math.min(mnY, y); mxY = Math.max(mxY, y);
                        mnZ = Math.min(mnZ, z); mxZ = Math.max(mxZ, z);
                    }
                    const sz = Math.max(mxX - mnX, mxY - mnY, mxZ - mnZ) + 1;
                    previewCamera.position.z = sz * 1.5;
                } else {
                    previewCamera.position.z = 100;
                }
            }
        });
        toggleWireBtn.addEventListener('click', () => { wireMode = !wireMode; if (previewMesh?.material) previewMesh.material.wireframe = wireMode; toggleWireBtn.textContent = wireMode ? 'ソリッド表示' : 'ワイヤー表示'; });
        document.addEventListener('keydown', e => { if (e.key === 'Escape' && previewModal.classList.contains('active')) closePreview(); });

        const origProcess = processFile;
        processFile = async function (f) {
            await origProcess(f);
            previewBtn.disabled = !((is3DModel && current3DVoxels.length > 0) || (!is3DModel && currentBlocks.length > 0));
        };

        const origProcessFiles = processFiles;
        processFiles = async function (files) {
            await origProcessFiles(files);
            previewBtn.disabled = !((is3DModel && current3DVoxels.length > 0) || (!is3DModel && currentBlocks.length > 0));
        };

        log('準備完了');
    </script>
</body>

</html>